// Automatically generated by MockGen. DO NOT EDIT!
// Source: github.com/sclevine/forge (interfaces: Container)

package mocks

import (
	gomock "github.com/golang/mock/gomock"
	engine "github.com/sclevine/forge/engine"
	io "io"
	time "time"
)

// Mock of Container interface
type MockContainer struct {
	ctrl     *gomock.Controller
	recorder *_MockContainerRecorder
}

// Recorder for MockContainer (not exported)
type _MockContainerRecorder struct {
	mock *MockContainer
}

func NewMockContainer(ctrl *gomock.Controller) *MockContainer {
	mock := &MockContainer{ctrl: ctrl}
	mock.recorder = &_MockContainerRecorder{mock}
	return mock
}

func (_m *MockContainer) EXPECT() *_MockContainerRecorder {
	return _m.recorder
}

func (_m *MockContainer) Background() error {
	ret := _m.ctrl.Call(_m, "Background")
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockContainerRecorder) Background() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Background")
}

func (_m *MockContainer) Close() error {
	ret := _m.ctrl.Call(_m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockContainerRecorder) Close() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Close")
}

func (_m *MockContainer) CloseAfterStream(_param0 *engine.Stream) error {
	ret := _m.ctrl.Call(_m, "CloseAfterStream", _param0)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockContainerRecorder) CloseAfterStream(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "CloseAfterStream", arg0)
}

func (_m *MockContainer) Commit(_param0 string) (string, error) {
	ret := _m.ctrl.Call(_m, "Commit", _param0)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockContainerRecorder) Commit(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Commit", arg0)
}

func (_m *MockContainer) CopyFrom(_param0 string) (engine.Stream, error) {
	ret := _m.ctrl.Call(_m, "CopyFrom", _param0)
	ret0, _ := ret[0].(engine.Stream)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockContainerRecorder) CopyFrom(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "CopyFrom", arg0)
}

func (_m *MockContainer) CopyTo(_param0 engine.Stream, _param1 string) error {
	ret := _m.ctrl.Call(_m, "CopyTo", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockContainerRecorder) CopyTo(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "CopyTo", arg0, arg1)
}

func (_m *MockContainer) ExtractTo(_param0 io.Reader, _param1 string) error {
	ret := _m.ctrl.Call(_m, "ExtractTo", _param0, _param1)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockContainerRecorder) ExtractTo(arg0, arg1 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "ExtractTo", arg0, arg1)
}

func (_m *MockContainer) HealthCheck() <-chan string {
	ret := _m.ctrl.Call(_m, "HealthCheck")
	ret0, _ := ret[0].(<-chan string)
	return ret0
}

func (_mr *_MockContainerRecorder) HealthCheck() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "HealthCheck")
}

func (_m *MockContainer) ID() string {
	ret := _m.ctrl.Call(_m, "ID")
	ret0, _ := ret[0].(string)
	return ret0
}

func (_mr *_MockContainerRecorder) ID() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "ID")
}

func (_m *MockContainer) Start(_param0 string, _param1 io.Writer, _param2 <-chan time.Time) (int64, error) {
	ret := _m.ctrl.Call(_m, "Start", _param0, _param1, _param2)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

func (_mr *_MockContainerRecorder) Start(arg0, arg1, arg2 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Start", arg0, arg1, arg2)
}
